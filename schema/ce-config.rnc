default namespace = "http://www.w3.org/1999/xhtml"
namespace c = "urn:cen.eu:en16931:cius-extension:2018"
namespace html = "http://www.w3.org/1999/xhtml"

start =
  # CIUS configuration
  element c:cius {
    
    # Metadata
    element c:meta {
      # Short identifier
      element c:shortName { text },
      # Name of CUIS/extension
      element c:name { text },
      # Identifier as defined in 7.6 Identification of core invoice usage specifications
      element c:id { text },
      # Identifier of specification that is being extended
      element c:extends { text }?,
      # Underlying specification
      element c:specification { text }?,
      # Version number
      element c:version { text },
      # Status of CUIZS/extension
      element c:status { "planned" | "development" | "active" | "revoked" },
      # Date of publication
      element c:date { xsd:date },
      # Publisher
      element c:publisher { html-rtf },
      # Governonr
      element c:governor { html-rtf },
      # Country to which CIUS/extension applies
      element c:country { text }?,
      # Sector to which CIUS/extension applies
      element c:sector { text }?,
      # Contact email for any questions and bug reports against CUIS/extension
      element c:contact { text },
      # Short description of CIUS/extensions
      element c:abstract { attribute xml:lang { text }?, html-rtf },
      # Link for more information
      element c:link { xsd:anyURI }?
    },
    # Text description
    description*,
    # Business rules imposed by CIUS/extension
    element c:rules {
      # Business rule
      element c:rule {
        # Unique ID for business rule (BR-{country}-{id} pattern is recommended)
        attribute id { text },
        description+,
        restrictions?,        
        implementation*
      }+
    }
  }

description =
  # Human readable description can contain mix of text and HTML markup if formatting is needed
  element c:description { attribute xml:lang { text }?, html-rtf }

restrictions =
  # Restrictions that are further applied
  element c:restrictions { (cardinality | technical | codelist | value | other | synonyms)+ }

cardinality = 
  # Constaint on cardinality
  element c:cardinality {
    attribute maxOccurs { xsd:integer | "unbounded" }?,
    attribute minOccurs { xsd:integer }?,
    term+
  }

technical =
  # Technical constaint
  element c:technical { empty }

codelist =
  # Codelist
  element c:codelist {
    name?,
    term+,
    codelist-value+
  }

value =
  # Restricted value domain
  # Restriction can be made using attributes similar to W3C XML Schema facets
  element c:value {
    # Regular expression describing allowed values
    attribute pattern { text }?,
    # Required length of value
    attribute length { xsd:nonNegativeInteger }?,
    # Maximum length of value
    attribute maxLength { xsd:nonNegativeInteger }?,
    # Maximal number of fraction digits
    attribute fractionDigits { xsd:nonNegativeInteger }?,
    # Maximal number of fraction digits
    attribute totalDigits { xsd:nonNegativeInteger }?,
    # Minimum allowed value
    attribute minInclusive { xsd:decimal }?,
    # Maximum allowed value
    attribute maxInclusive { xsd:decimal }?,
    term+
  }
  
other =
  # FIXME: what should be content model here
  element c:other {
    term+
  }  
  
pattern =
  # Pattern for allowed values expressed as a regular expression (W3C XML Schema syntax is supported)
  element c:pattern { text }

name = 
  # Name 
  element c:name { text }

codelist-value =
  # Allowed value
  element c:value { text }

term =
  # Reference to business term (i.e. BT-NN)
  element c:term { text }

synonyms =
  # Synonyms of term
  element c:synonyms { term+, synonym+ }
  
synonym =
  # Synonym of term
  element c:synonym { attribute xml:lang { text }?, text }


html-rtf = text & any-html*

any-html = element html:* { any-attribute*, (any-html* & text) }
any-attribute = attribute * { text }

implementation =
  # Technical implementation of constraint in any schema language, usually in Schematron
  element c:implementation {
    # To which syntax implementation applies?
    attribute syntax { "UBL" | "CII" }, 
    any 
  }

any = element * { any-attribute*, (any* & text) }